\chapter{Επίλογος}

\section{Σύνοψη}

Συνοψίζουμε τα όσα έχουμε παρουσιαστεί έως τώρα στην παρούσα εργασία στον αναγνώστη.
\newline

Αρχικά, έγινε αναφορά στις νέες τάσεις του τρόπου να εκτελούμε
\en{computational tasks}, και συγκεκριμένα στο \en{cloud computing},
το οποίο είναι το μοντέλο που χαρακτηρίζει την σύγχρονη εποχή
στην ιστορία των υπολογιστών. Αναλύθηκε η εικονικοποίηση, η
τεχνολογία που επιτρέπει την ύπαρξη του \en{cloud computing}, καθώς
και τα δίαφορα είδη της που έχουν προκύψει λόγο της δυσκολίας του
να εικονικοποιηθεί ένα πλήρες υπολογιστικό σύστημα. Κατέστη
σαφες ότι η φιλοσοφία των δημοφιλών λειτουργικών συστημάτων
γεννήθηκε σε μια εποχή απλούστερων συστημάτων και περιορισμένων
πόρων και άρα ότι δεν ταιριάζει τέλεια στο \en{cloud computing}.
Παρουσιάστηκαν, λοιπόν, τα εξής προβλήματα με την εως τώρα
εικονικοποίηση. Το πρώτο που είδαμε, είναι η υπερβολική
πολυπλοκότητα των συμβατικών λειτουργικών συστημάτων και οι
υψηλές απαιτήσεις σε πόρους αναλογικά με τις πλέον απλές
εφαρμογές που φιλοξενούν. Το δεύτερο είναι η μη βέλτιστη
διαχείριση των πόρων, και συγκεκριμένα της υφιστάμενης μνήμης
από τα συμβατικά λειτουργικά συστήματα, όταν αυτά βρίσκονται εντός
εικονικοποιημένων περιβαλλόντων.
\newline

Στη συνέχεια, αναλύθηκαν διάφορες τεχνικές αντιμετώπισης των ανωτέρων προβλημάτων.
Το πρώτο πρόβλημα λύνεται με τα \en{unikernels}, αυτές τις ευέλικτες και απλές
εικονικές μηχανές. Κρίθηκε σκόπιμο να αναλυθούν τα
χαρακτηριστικά αυτών και να αναφερθούν τα διάφορα
\en{frameworks} που υπάρχουν. Ειδικά για το \en{Rumprun
framework}, με το οποίο εργαστήκαμε, η ανάλυση επάνω σε
αυτό ήταν εις βάθος, ως έπρεπε. Για το δεύτερο
πρόβλημα προσφέρονται διάφορες λύσεις, ενώ η προσοχή δόθηκε
στην πτητική μνήμη \en{utmem}, καθώς αναλύθηκε η ιστορία
της και τα χαρακτηριστικά της.
\newline

Τελικά, αποδείχθηκε πως αυτές οι δύο τεχνολογίες μπορούν να
συνδυαστούν άψογα, δημιουργώντας \en{unikernels} με \en{utmem} δυνατότητες.
Με σεβασμό στην φιλοσοφία του \en{Rumprun} και στην σχεδίαση της \en{utmem}, αυτές
οι δύο τεχνολογίες εναρμονίστηκαν άψογα.
Μάλιστα, με βάση τις μετρήσεις πο παρατέθηκαν, η ένωση αυτή
δεν είναι άνευ αξίας, αλλά έχει τέλεια εφαρμογή σε συγκεκριμένα
ενδεχόμενα εκτέλεσης εικονικοποιημένων συστημάτων. Διαπιστώθηκε, δε, πως
η επίδοση του νέου μηχανισμού ανώτερη από αυτή της αυθεντικής υλοποίησης.




\section{Μελλοντικές κατευθύνσεις}


Μέχρι στιγμής, η αδυναμία της έκδοσης \en{utmem} για το \en{Rumprun} είναι πως
ως μηχανισμός αποθήκευσης δεδομένων είναι σχετικά αργός σε σχέση
με την αποθήκευση στη μνήμη της εικονικής μηχανής. Θα ήταν δυνατόν
να βελτιστοποιήσουμε περαιτέρω με διάφορες τεχνικές την χρήση της
\en{utmem} ώστε οι ταχύτητες να πλησιάζουν την \en{in-memory} αποθήκευση των
δεδομένων. Κύρια αδυναμία είναι πως, με βάση την μορφή του μηχανισμού,
απαιτείται ένα \en{hypercall} για κάθε αίτηση \en{utmem}. Ανεμένουμε πως αν
μειώνονταν ο αριθμός των \en{hypercalls} που απαιτούνται θα αυξάνονταν οι
επιδόσεις του μηχανισμού.
\newline

Μια λύση θα ήταν να κρατάμε ένα \en{buffer} μνήμης με δεδομένα, τα οποία
θα μεταφέρονταν στην \en{tmem pool} όταν περνούσαν ένα προκαθορισμένο
μέγεθος. Έτσι δεν θα χρειάζονταν να κάνουμε ένα \en{hypercall} ανά
\en{request}, αλλά θα εκμεταλλευόμασταν \en{bulk-insertions} με μόνο ένα
\en{hypercall}. Επί παραδείγματι, ας φανταστούμε πως ερχονται χίλια
αιτήματα \en{utmem} όπου το καθένα επιθυμεί να αποθηκεύσει δεδομένα
μεγέθους ενός \en{kilo byte}.  Θα μπορούσαμε να κάνουμε μαζική
εισαγωγή όλων αυτών, όταν συμπληρωθεί και το π.χ. χιλιοστό αίτημα
με μόνο ένα \en{hypercall} με δεδομένα μεγέθους χίλια επί ένα
\en{kilobyte} συν ό,τι χρειάζεται για τα κλειδιά, αντί για χίλια «μικρά» \en{hypercalls}.
\newline

Άλλη κατεύθυνση θα ήταν τα δεδομένα να συμπιέζονται εντός του
\en{unikernel}, πριν αποσταλούν στο \en{backend}, ώστε πάλι να μειώνεται
ο αριθμός των απαιτούμενων \en{hypercalls}. Ωστόσο, επειδή η συμπίεση
δεδομένων καταναλώνει σημαντική επεξεργαστική ισχύ, αυτό θα
αφορούσε σενάρια εκτέλεσης όπου ο επεξεργαστής είναι πόρος σε
αφθονία, ενώ η μνήμη σε σχετική έλλειψη. Μάλιστα, θα μπορούσε η
εκάστοτε εφαρμογή που τρέχει ως \en{unikernel}, να εξειδικεύει τον
αλγόριθμο συμπίεσης ώστε να ταιριάζει στο είδος των δεδομένων της καλύτερα.
Η εξειδίκευση αυτή είναι πιο εύκολη από την πλευρά του unikernel, καθώς θεωρητικά ο
προγραμματιστής γνωρίζει την φύση των δεδομένων, ενώ το backend εστιάζει στην αποθήκευση
αφηρημένης μορφής δεδομένων.
\newline

Όσον αφορά \en{use case} με πολλές προσβάσεις στην μνήμη επάνω στα
ίδια δεδομένα, η
αποθήκευση και ανάκτηση των δεδομένων με ένα \en{tmem pool} από
μόνη της μειώνει την απόδοση του συστήματος. Γνωστή και
αποδοτική πλέον λύση
τέτοιων περιπτώσεων είναι η χρήση κρυφών μνημών. Στην περίπτωση
μας θα ήταν η ύπαρξη ενός μικρού \en{memory area} μέσα στο
\en{unikernel}, είτε στο ανώτερο επίπεδο είτε στο
επίπεδο του \en{driver}, στο οποίο να βρίσκονται τα περισσότερα συχνά
ανταλλάξιμα δεδομένα μεταξύ του \en{frontend} και του \en{backend}.
\newline

Αναθεωρώντας ακόμα περισσότερο την φιλοσοφία της \en{utmem}, η
χρήση κάποιου ασύχρονου μηχανισμού επικοινωνίας \en{host} και \en{guest},
και όχι του σύγχρονου \en{hypercall}, θα έλυνε τα προβλήματα που
προέρχονται από το \en{blocking} των αιτημάτων. Βέβαια, αυτό
απαιτεί σημαντικά περισσότερη
προσοχή ως προς την ασφάλεια, την αποφυγή αδιεξόδων (\en{deadlock}),
και την εγγύηση πως τα δεδομένα μας θα είναι πάντα διαθέσιμα
και ασφαλή.
\newline

Τέλος, το γεγονός πως επιτρέψαμε την χρήση της \en{utmem} από
\en{unikernels} στηριζόμενοι στο \en{Rumprun}, δεν σημαίνει πως τα άλλα
\en{frameworks} δεν είναι συμβατά. Ανάλογα με το πόσο εύκολο
ή δύσκολο είναι σε έναν προγραμματιστή να προσθέσει μια
κλήση επόπτη στο \en{framework} που τον ενδιαφέρει, θεωρούμε
πως τόσο εύκολο ή δύσκολο είναι και το \en{porting} της \en{utmem}.
Για παράδειγμα, το \en{mirageOS} αν και σχεδιάστηκε για το
\en{Xen hypervisor}, υποστηρίζει και το \en{KVM} πλέον, οπότε πιθανότατα
η ενσωμάτωση του μηχανισμού της \en{utmem} να είναι
σχετικά εύκολη διαδικασία. Το ίδιο ισχύει για τα
περισσότερα \en{frameworks} που υποστηρίζουν το \en{KVM} ως επόπτη.
